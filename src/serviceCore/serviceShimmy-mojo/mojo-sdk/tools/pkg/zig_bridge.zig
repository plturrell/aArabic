// Mojo Package Manager - Zig Build System Bridge
// Day 95: Coordinate Mojo packages with Zig build.zig

const std = @import("std");
const manifest = @import("manifest.zig");
const workspace_mod = @import("workspace.zig");
const resolver = @import("resolver.zig");
const Allocator = std.mem.Allocator;

// ============================================================================
// Build Configuration
// ============================================================================

pub const BuildTarget = enum {
    exe,      // Executable
    lib,      // Library (static or dynamic)
    test_exe, // Test executable
};

pub const BuildMode = enum {
    Debug,
    ReleaseSafe,
    ReleaseFast,
    ReleaseSmall,
};

pub const BuildConfig = struct {
    name: []const u8,
    target: BuildTarget,
    mode: BuildMode,
    source_files: std.ArrayList([]const u8),
    dependencies: std.ArrayList([]const u8),
    allocator: Allocator,
    
    pub fn init(allocator: Allocator, name: []const u8, target: BuildTarget) !BuildConfig {
        return BuildConfig{
            .name = try allocator.dupe(u8, name),
            .target = target,
            .mode = .Debug,
            .source_files = std.ArrayList([]const u8){},
            .dependencies = std.ArrayList([]const u8){},
            .allocator = allocator,
        };
    }
    
    pub fn deinit(self: *BuildConfig) void {
        self.allocator.free(self.name);
        for (self.source_files.items) |file| {
            self.allocator.free(file);
        }
        self.source_files.deinit(self.allocator);
        for (self.dependencies.items) |dep| {
            self.allocator.free(dep);
        }
        self.dependencies.deinit(self.allocator);
    }
    
    pub fn addSourceFile(self: *BuildConfig, file_path: []const u8) !void {
        const dup = try self.allocator.dupe(u8, file_path);
        try self.source_files.append(self.allocator, dup);
    }
    
    pub fn addDependency(self: *BuildConfig, dep_name: []const u8) !void {
        const dup = try self.allocator.dupe(u8, dep_name);
        try self.dependencies.append(self.allocator, dup);
    }
};

// ============================================================================
// Zig Build Script Generator
// ============================================================================

pub const ZigBuildGenerator = struct {
    allocator: Allocator,
    
    pub fn init(allocator: Allocator) ZigBuildGenerator {
        return ZigBuildGenerator{ .allocator = allocator };
    }
    
    /// Generate build.zig for a package
    pub fn generateBuildScript(self: *ZigBuildGenerator, pkg: manifest.PackageManifest, config: BuildConfig) ![]const u8 {
        var buffer = std.ArrayList(u8){};
        defer buffer.deinit(self.allocator);
        
        const writer = buffer.writer(self.allocator);
        
        // Header
        try writer.writeAll("// Auto-generated by Mojo Package Manager\n");
        try writer.writeAll("const std = @import(\"std\");\n\n");
        
        try writer.writeAll("pub fn build(b: *std.Build) void {\n");
        try writer.writeAll("    const target = b.standardTargetOptions(.{});\n");
        try writer.writeAll("    const optimize = b.standardOptimizeOption(.{});\n\n");
        
        // Create artifact
        switch (config.target) {
            .exe => {
                try writer.print("    const exe = b.addExecutable(.{{\n", .{});
                try writer.print("        .name = \"{s}\",\n", .{pkg.name});
                try writer.writeAll("        .target = target,\n");
                try writer.writeAll("        .optimize = optimize,\n");
                try writer.writeAll("    });\n\n");
            },
            .lib => {
                try writer.print("    const lib = b.addStaticLibrary(.{{\n", .{});
                try writer.print("        .name = \"{s}\",\n", .{pkg.name});
                try writer.writeAll("        .target = target,\n");
                try writer.writeAll("        .optimize = optimize,\n");
                try writer.writeAll("    });\n\n");
            },
            .test_exe => {
                try writer.print("    const tests = b.addTest(.{{\n", .{});
                try writer.print("        .name = \"{s}-test\",\n", .{pkg.name});
                try writer.writeAll("        .target = target,\n");
                try writer.writeAll("        .optimize = optimize,\n");
                try writer.writeAll("    });\n\n");
            },
        }
        
        // Add source files
        for (config.source_files.items) |file| {
            const artifact_name = switch (config.target) {
                .exe => "exe",
                .lib => "lib",
                .test_exe => "tests",
            };
            try writer.print("    {s}.addCSourceFile(.{{ .file = b.path(\"{s}\") }});\n", .{ artifact_name, file });
        }
        
        // Add dependencies
        if (config.dependencies.items.len > 0) {
            try writer.writeAll("\n    // Dependencies\n");
            for (config.dependencies.items) |dep| {
                const artifact_name = switch (config.target) {
                    .exe => "exe",
                    .lib => "lib",
                    .test_exe => "tests",
                };
                try writer.print("    // {s}.linkLibrary({s});\n", .{ artifact_name, dep });
            }
        }
        
        // Install step
        switch (config.target) {
            .exe => {
                try writer.writeAll("\n    b.installArtifact(exe);\n");
                try writer.writeAll("    const run_cmd = b.addRunArtifact(exe);\n");
                try writer.writeAll("    const run_step = b.step(\"run\", \"Run the app\");\n");
                try writer.writeAll("    run_step.dependOn(&run_cmd.step);\n");
            },
            .lib => {
                try writer.writeAll("\n    b.installArtifact(lib);\n");
            },
            .test_exe => {
                try writer.writeAll("\n    const run_tests = b.addRunArtifact(tests);\n");
                try writer.writeAll("    const test_step = b.step(\"test\", \"Run tests\");\n");
                try writer.writeAll("    test_step.dependOn(&run_tests.step);\n");
            },
        }
        
        try writer.writeAll("}\n");
        
        return try buffer.toOwnedSlice(self.allocator);
    }
    
    /// Generate build.zig.zon for dependencies
    pub fn generateZonFile(self: *ZigBuildGenerator, pkg: manifest.PackageManifest, resolution: resolver.Resolution) ![]const u8 {
        var buffer = std.ArrayList(u8){};
        defer buffer.deinit(self.allocator);
        
        const writer = buffer.writer(self.allocator);
        
        try writer.writeAll(".{\n");
        try writer.print("    .name = \"{s}\",\n", .{pkg.name});
        
        const version_str = try pkg.version.toString(self.allocator);
        defer self.allocator.free(version_str);
        try writer.print("    .version = \"{s}\",\n", .{version_str});
        
        try writer.writeAll("    .dependencies = .{\n");
        
        // Add resolved dependencies
        for (resolution.dependencies.items) |dep| {
            if (dep.source == .Path) {
                if (dep.path) |path| {
                    try writer.print("        .{s} = .{{ .path = \"{s}\" }},\n", .{ dep.name, path });
                }
            } else if (dep.source == .Registry) {
                const dep_version = try dep.version.toString(self.allocator);
                defer self.allocator.free(dep_version);
                try writer.print("        .{s} = .{{ .version = \"{s}\" }},\n", .{ dep.name, dep_version });
            }
        }
        
        try writer.writeAll("    },\n");
        try writer.writeAll("}\n");
        
        return try buffer.toOwnedSlice(self.allocator);
    }
};

// ============================================================================
// Workspace Build Coordinator
// ============================================================================

pub const WorkspaceBuildCoordinator = struct {
    allocator: Allocator,
    workspace: *workspace_mod.Workspace,
    generator: ZigBuildGenerator,
    
    pub fn init(allocator: Allocator, ws: *workspace_mod.Workspace) WorkspaceBuildCoordinator {
        return WorkspaceBuildCoordinator{
            .allocator = allocator,
            .workspace = ws,
            .generator = ZigBuildGenerator.init(allocator),
        };
    }
    
    /// Generate build scripts for all workspace members
    pub fn generateWorkspaceBuildScripts(self: *WorkspaceBuildCoordinator) !std.ArrayList(MemberBuildScript) {
        var scripts = std.ArrayList(MemberBuildScript){};
        
        for (self.workspace.members.items) |member| {
            var config = try BuildConfig.init(self.allocator, member.name, .lib);
            defer config.deinit();
            
            // Add dependencies from manifest
            for (member.manifest.dependencies.items) |dep| {
                try config.addDependency(dep.name);
            }
            
            const script = try self.generator.generateBuildScript(member.manifest, config);
            
            const member_script = MemberBuildScript{
                .member_name = try self.allocator.dupe(u8, member.name),
                .script_content = script,
                .allocator = self.allocator,
            };
            
            try scripts.append(self.allocator, member_script);
        }
        
        return scripts;
    }
    
    /// Create a unified build.zig for the entire workspace
    pub fn generateUnifiedBuildScript(self: *WorkspaceBuildCoordinator) ![]const u8 {
        var buffer = std.ArrayList(u8){};
        defer buffer.deinit(self.allocator);
        
        const writer = buffer.writer(self.allocator);
        
        try writer.writeAll("// Auto-generated workspace build.zig\n");
        try writer.writeAll("const std = @import(\"std\");\n\n");
        
        try writer.writeAll("pub fn build(b: *std.Build) void {\n");
        try writer.writeAll("    const target = b.standardTargetOptions(.{});\n");
        try writer.writeAll("    const optimize = b.standardOptimizeOption(.{});\n\n");
        
        try writer.writeAll("    // Build all workspace members\n");
        for (self.workspace.members.items) |member| {
            try writer.print("    // Member: {s}\n", .{member.name});
            try writer.print("    const {s} = b.addStaticLibrary(.{{\n", .{member.name});
            try writer.print("        .name = \"{s}\",\n", .{member.name});
            try writer.writeAll("        .target = target,\n");
            try writer.writeAll("        .optimize = optimize,\n");
            try writer.writeAll("    });\n");
            try writer.print("    b.installArtifact({s});\n\n", .{member.name});
        }
        
        try writer.writeAll("}\n");
        
        return try buffer.toOwnedSlice(self.allocator);
    }
};

pub const MemberBuildScript = struct {
    member_name: []const u8,
    script_content: []const u8,
    allocator: Allocator,
    
    pub fn deinit(self: *MemberBuildScript) void {
        self.allocator.free(self.member_name);
        self.allocator.free(self.script_content);
    }
};

// ============================================================================
// Build Executor
// ============================================================================

pub const BuildExecutor = struct {
    allocator: Allocator,
    
    pub fn init(allocator: Allocator) BuildExecutor {
        return BuildExecutor{ .allocator = allocator };
    }
    
    /// Execute zig build command
    pub fn executeBuild(self: *BuildExecutor, project_path: []const u8, mode: BuildMode) !void {
        _ = self;
        
        const mode_str = switch (mode) {
            .Debug => "Debug",
            .ReleaseSafe => "ReleaseSafe",
            .ReleaseFast => "ReleaseFast",
            .ReleaseSmall => "ReleaseSmall",
        };
        
        std.debug.print("Executing: zig build -Doptimize={s} in {s}\n", .{ mode_str, project_path });
        // Would actually spawn process: zig build -Doptimize=<mode>
    }
    
    /// Execute zig test command
    pub fn executeTest(self: *BuildExecutor, project_path: []const u8) !void {
        _ = self;
        std.debug.print("Executing: zig build test in {s}\n", .{project_path});
        // Would actually spawn process: zig build test
    }
};

// ============================================================================
// Tests
// ============================================================================

test "BuildConfig: creation" {
    var config = try BuildConfig.init(std.testing.allocator, "test-app", .exe);
    defer config.deinit();
    
    try std.testing.expectEqualStrings("test-app", config.name);
    try std.testing.expect(config.target == .exe);
}

test "BuildConfig: add source file" {
    var config = try BuildConfig.init(std.testing.allocator, "test-lib", .lib);
    defer config.deinit();
    
    try config.addSourceFile("src/main.zig");
    
    try std.testing.expectEqual(@as(usize, 1), config.source_files.items.len);
    try std.testing.expectEqualStrings("src/main.zig", config.source_files.items[0]);
}

test "BuildConfig: add dependency" {
    var config = try BuildConfig.init(std.testing.allocator, "test-app", .exe);
    defer config.deinit();
    
    try config.addDependency("http-client");
    
    try std.testing.expectEqual(@as(usize, 1), config.dependencies.items.len);
    try std.testing.expectEqualStrings("http-client", config.dependencies.items[0]);
}

test "ZigBuildGenerator: generate simple exe" {
    var generator = ZigBuildGenerator.init(std.testing.allocator);
    
    const version = try manifest.Version.parse(std.testing.allocator, "1.0.0");
    var pkg = try manifest.PackageManifest.init(std.testing.allocator, "my-app", version);
    defer pkg.deinit();
    
    var config = try BuildConfig.init(std.testing.allocator, "my-app", .exe);
    defer config.deinit();
    
    try config.addSourceFile("src/main.zig");
    
    const script = try generator.generateBuildScript(pkg, config);
    defer std.testing.allocator.free(script);
    
    try std.testing.expect(std.mem.indexOf(u8, script, "my-app") != null);
    try std.testing.expect(std.mem.indexOf(u8, script, "addExecutable") != null);
}

test "ZigBuildGenerator: generate library" {
    var generator = ZigBuildGenerator.init(std.testing.allocator);
    
    const version = try manifest.Version.parse(std.testing.allocator, "1.0.0");
    var pkg = try manifest.PackageManifest.init(std.testing.allocator, "my-lib", version);
    defer pkg.deinit();
    
    var config = try BuildConfig.init(std.testing.allocator, "my-lib", .lib);
    defer config.deinit();
    
    const script = try generator.generateBuildScript(pkg, config);
    defer std.testing.allocator.free(script);
    
    try std.testing.expect(std.mem.indexOf(u8, script, "addStaticLibrary") != null);
}

test "ZigBuildGenerator: generate zon file" {
    var generator = ZigBuildGenerator.init(std.testing.allocator);
    
    const version = try manifest.Version.parse(std.testing.allocator, "1.0.0");
    var pkg = try manifest.PackageManifest.init(std.testing.allocator, "my-pkg", version);
    defer pkg.deinit();
    
    var resolution = resolver.Resolution.init(std.testing.allocator);
    defer resolution.deinit();
    
    const zon = try generator.generateZonFile(pkg, resolution);
    defer std.testing.allocator.free(zon);
    
    try std.testing.expect(std.mem.indexOf(u8, zon, "my-pkg") != null);
    try std.testing.expect(std.mem.indexOf(u8, zon, "1.0.0") != null);
}

test "BuildExecutor: creation" {
    const executor = BuildExecutor.init(std.testing.allocator);
    _ = executor;
}

test "MemberBuildScript: cleanup" {
    var script = MemberBuildScript{
        .member_name = try std.testing.allocator.dupe(u8, "test-member"),
        .script_content = try std.testing.allocator.dupe(u8, "content"),
        .allocator = std.testing.allocator,
    };
    defer script.deinit();
    
    try std.testing.expectEqualStrings("test-member", script.member_name);
}

test "BuildMode: enum values" {
    const debug: BuildMode = .Debug;
    const release: BuildMode = .ReleaseFast;
    
    try std.testing.expect(debug == .Debug);
    try std.testing.expect(release == .ReleaseFast);
}

test "BuildTarget: enum values" {
    const exe: BuildTarget = .exe;
    const lib: BuildTarget = .lib;
    const test_exe: BuildTarget = .test_exe;
    
    try std.testing.expect(exe == .exe);
    try std.testing.expect(lib == .lib);
    try std.testing.expect(test_exe == .test_exe);
}
