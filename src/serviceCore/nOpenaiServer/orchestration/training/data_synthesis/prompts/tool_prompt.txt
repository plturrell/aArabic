Restaurant tools:
"""Toolkit for the restaurant domain."""
from typing import List, Dict
import json

from tau2.environment.toolkit import ToolKitBase, ToolType, is_tool
from tau2.domains.restaurant.data_model import (
    Dish,
    LineEntry,
    Patron,
    PatronLocation,
    PaymentInstrument,
    RestaurantDB,
    ServiceTicket,
    TableInfo,
    TicketCharge,
    Plate,
)


class RestaurantTools(ToolKitBase):
    """Frequently-used tools for the restaurant domain."""

    db: RestaurantDB

    def __init__(self, db: RestaurantDB) -> None:
        super().__init__(db)

    # -----------------------
    # Internal helper methods
    # -----------------------
    def _get_ticket(self, ticket_ref: str) -> ServiceTicket:
        """Get a service ticket from the database."""
        if ticket_ref not in self.db.service_tickets:
            raise ValueError("Ticket not found")
        return self.db.service_tickets[ticket_ref]

    def _get_patron(self, guest_ref: str) -> Patron:
        """Get a patron from the database."""
        if guest_ref not in self.db.patron_registry:
            raise ValueError("Patron not found")
        return self.db.patron_registry[guest_ref]

    def _get_dish(self, dish_ref: str) -> Dish:
        """Get a dish from the database."""
        if dish_ref not in self.db.menu_board:
            raise ValueError("Dish not found")
        return self.db.menu_board[dish_ref]

    def _get_plate(self, dish_ref: str, plate_ref: str) -> Plate:
        """Get a plate selection from a dish."""
        dish = self._get_dish(dish_ref)
        if plate_ref not in dish.selections:
            raise ValueError("Plate not found")
        return dish.selections[plate_ref]

    def _get_instrument(self, guest_ref: str, instrument_ref: str) -> PaymentInstrument:
        """Get a saved payment instrument for a patron."""
        patron = self._get_patron(guest_ref)
        if instrument_ref not in patron.saved_instruments:
            raise ValueError("Payment instrument not found")
        return patron.saved_instruments[instrument_ref]

    def _is_placed_ticket(self, ticket: ServiceTicket) -> bool:
        """Check if the ticket is in 'placed' state (modifiable)."""
        return ticket.state == "placed"

    def _find_dish_by_plate(self, plate_ref: str) -> Dish:
        """Find the dish that contains the given plate_ref."""
        for dish in self.db.menu_board.values():
            if plate_ref in dish.selections:
                return dish
        raise ValueError("Plate not found in any dish")

    # -------------
    # Generic tools
    # -------------
    @is_tool(ToolType.GENERIC)
    def calculate(self, expression: str) -> str:
        """
        Calculate the result of a mathematical expression.

        Args:
            expression: The mathematical expression to calculate, such as '2 + 2'.
                        The expression can contain numbers, operators (+, -, *, /), parentheses, and spaces.

        Returns:
            The result of the mathematical expression (rounded to 2 decimals).

        Raises:
            ValueError: If the expression is invalid or contains invalid characters.
        """
        if not all(char in "0123456789+-*/(). " for char in expression):
            raise ValueError("Invalid characters in expression")
        return str(round(float(eval(expression, {"__builtins__": None}, {})), 2))

    @is_tool(ToolType.GENERIC)
    def transfer_to_human_agents(self, summary: str) -> str:
        """
        Transfer the user to a human agent, with a summary of the user's issue.
        Only transfer if
         - the user explicitly asks for a human agent, or
         - given the policy and the available tools, you cannot solve the user's issue.

        Args:
            summary: A concise summary of the user's issue.

        Returns:
            A message indicating the user has been transferred to a human agent.
        """
        return "Transfer successful"

    # ----------
    # Read tools
    # ----------
    @is_tool(ToolType.READ)
    def get_ticket_details(self, ticket_ref: str) -> ServiceTicket:
        """Get the current state and details of a service ticket.

        Args:
            ticket_ref: The ticket reference, such as 'TCKT-00001'.

        Returns:
            ServiceTicket: The ticket details.

        Raises:
            ValueError: If the ticket is not found.
        """
        return self._get_ticket(ticket_ref)

    @is_tool(ToolType.READ)
    def get_dish_details(self, dish_ref: str) -> Dish:
        """Get the menu details of a dish.

        Args:
            dish_ref: The dish reference, such as 'DISH-0001'.

        Returns:
            Dish: The dish details.

        Raises:
            ValueError: If the dish is not found.
        """
        return self._get_dish(dish_ref)

    @is_tool(ToolType.READ)
    def get_patron_details(self, guest_ref: str) -> Patron:
        """Get the details of a patron, including their saved instruments and ticket history.

        Args:
            guest_ref: The patron reference, such as 'GUEST-0001'.

        Returns:
            Patron: The patron details.

        Raises:
            ValueError: If the patron is not found.
        """
        return self._get_patron(guest_ref)

    @is_tool(ToolType.READ)
    def list_all_dishes(self) -> str:
        """List the title and dish_ref of all dishes.

        Returns:
            str: A JSON string mapping dish titles to their dish_refs, sorted alphabetically by title.
        """
        mapping = {dish.title: dish.dish_ref for dish in self.db.menu_board.values()}
        return json.dumps(mapping, sort_keys=True)

    @is_tool(ToolType.READ)
    def find_patron_ref_by_email(self, email: str) -> str:
        """Find patron reference by contact email.

        Args:
            email: The email of the patron, such as 'guest@example.com'.

        Returns:
            str: The guest_ref if found.

        Raises:
            ValueError: If the patron is not found.
        """
        for guest_ref, patron in self.db.patron_registry.items():
            if patron.contact_email.lower() == email.lower():
                return guest_ref
        raise ValueError("Patron not found")

    @is_tool(ToolType.READ)
    def find_patron_ref_by_name_zip(self, given: str, family: str, postal_code: str) -> str:
        """Find patron reference by name and postal code. Use when email is unknown or not found.

        Args:
            given: The given (first) name, such as 'John'.
            family: The family (last) name, such as 'Doe'.
            postal_code: The postal code, such as '12345'.

        Returns:
            str: The guest_ref if found.

        Raises:
            ValueError: If the patron is not found.
        """
        for guest_ref, patron in self.db.patron_registry.items():
            if (
                patron.identity.given.lower() == given.lower()
                and patron.identity.family.lower() == family.lower()
                and patron.location.postal_code == postal_code
            ):
                return guest_ref
        raise ValueError("Patron not found")

    # -----------
    # Write tools
    # -----------
    @is_tool(ToolType.WRITE)
    def cancel_placed_ticket(self, ticket_ref: str, reason: str) -> ServiceTicket:
        """Cancel a placed ticket. If the ticket has already started preparation or is delivered,
        it cannot be cancelled. The agent must explain the cancellation details and ask for explicit
        user confirmation (yes/no) to proceed. Upon cancellation, refund entries will be recorded
        for any prior payments.

        Args:
            ticket_ref: The ticket reference, such as 'TCKT-00001'.
            reason: The reason for cancellation (e.g., 'no longer needed', 'ordered by mistake').

        Returns:
            ServiceTicket: The ticket details after the cancellation.

        Raises:
            ValueError: If the ticket is not in 'placed' state.
        """
        ticket = self._get_ticket(ticket_ref)
        if ticket.state != "placed":
            raise ValueError("Only tickets in 'placed' state can be cancelled")

        # Record refunds for any 'payment' charges
        refunds: List[TicketCharge] = []
        for ch in ticket.charges:
            if ch.kind == "payment":
                refunds.append(
                    TicketCharge(kind="refund", total=ch.total, instrument_ref=ch.instrument_ref)
                )

        ticket.charges.extend(refunds)
        ticket.state = "cancelled"
        # Note: ServiceTicket has no explicit cancel_reason field; reason can be kept externally/logged.
        return ticket

    @is_tool(ToolType.WRITE)
    def modify_placed_ticket_dropoff(
        self,
        ticket_ref: str,
        line_one: str,
        line_two: str,
        municipality: str,
        province: str,
        nation: str,
        postal_code: str,
    ) -> ServiceTicket:
        """Modify the dropoff address of a placed delivery ticket.
        The agent must explain the update and ask for explicit user confirmation (yes/no) to proceed.

        Args:
            ticket_ref: The ticket reference, such as 'TCKT-00001'.
            line_one: Primary address line.
            line_two: Secondary address line.
            municipality: City or municipality.
            province: State or province.
            nation: Country name.
            postal_code: Postal or ZIP code.

        Returns:
            ServiceTicket: The ticket details after the modification.

        Raises:
            ValueError: If the ticket is not 'placed' or not a delivery ticket.
        """
        ticket = self._get_ticket(ticket_ref)
        if not self._is_placed_ticket(ticket):
            raise ValueError("Non-placed ticket cannot be modified")
        if ticket.service_mode != "delivery":
            raise ValueError("Only delivery tickets have a dropoff address")

        ticket.dropoff = PatronLocation(
            line_one=line_one,
            line_two=line_two,
            municipality=municipality,
            province=province,
            nation=nation,
            postal_code=postal_code,
        )
        return ticket

    @is_tool(ToolType.WRITE)
    def modify_placed_ticket_table(
        self,
        ticket_ref: str,
        zone: str,
        table_no: str,
        seat_count: int,
    ) -> ServiceTicket:
        """Modify the table information for a placed dine-in ticket.
        The agent must explain the update and ask for explicit user confirmation (yes/no) to proceed.

        Args:
            ticket_ref: The ticket reference, such as 'TCKT-00001'.
            zone: Dining area or zone identifier.
            table_no: Table number.
            seat_count: Number of seats at the table.

        Returns:
            ServiceTicket: The ticket details after the modification.

        Raises:
            ValueError: If the ticket is not 'placed' or not a dine-in ticket.
        """
        ticket = self._get_ticket(ticket_ref)
        if not self._is_placed_ticket(ticket):
            raise ValueError("Non-placed ticket cannot be modified")
        if ticket.service_mode != "dine_in":
            raise ValueError("Only dine-in tickets have table information")

        ticket.table_info = TableInfo(zone=zone, table_no=table_no, seat_count=seat_count)
        return ticket

    @is_tool(ToolType.WRITE)
    def modify_placed_ticket_items(
        self,
        ticket_ref: str,
        plate_refs: List[str],
        new_plate_refs: List[str],
        instrument_ref: str,
    ) -> ServiceTicket:
        """Modify plate selections in a placed ticket to new plate selections of the same dish.
        This function can only be applied to tickets in 'placed' state. The agent needs to explain the
        modification and ask for explicit user confirmation (yes/no) to proceed.

        Args:
            ticket_ref: The ticket reference, such as 'TCKT-00001'.
            plate_refs: The current plate_refs to be modified; duplicates allowed.
            new_plate_refs: The new plate_refs to replace with; must match positional count and be same dish.
            instrument_ref: The payment instrument to charge/refund the price difference.

        Returns:
            ServiceTicket: The ticket details after the modification.

        Raises:
            ValueError: If the ticket is not 'placed'.
            ValueError: If the plate_refs do not exist in the ticket (considering duplicates).
            ValueError: If new plates do not exist, are not served today, or do not belong to the same dish as the originals.
            ValueError: If the number of items to be modified does not match.
            ValueError: If the payment instrument does not exist for the patron.
        """
        ticket = self._get_ticket(ticket_ref)
        if not self._is_placed_ticket(ticket):
            raise ValueError("Non-placed ticket cannot be modified")

        # Validate instrument exists for the patron
        self._get_instrument(ticket.guest_ref, instrument_ref)

        # Check counts of existing plates in ticket
        ticket_plate_refs = [entry.plate_ref for entry in ticket.line_entries]
        for pr in plate_refs:
            if plate_refs.count(pr) > ticket_plate_refs.count(pr):
                raise ValueError(f"Plate {pr} not found in the ticket the requested number of times")

        if len(plate_refs) != len(new_plate_refs):
            raise ValueError("The number of plates to be modified should match")

        # Compute price differences and validate new plates
        diff_total = 0.0
        # Keep track of which line entries have been modified for duplicates
        used_indices: Dict[str, int] = {}  # plate_ref -> how many times consumed
        modifications: List[Dict] = []  # store (index, new_plate, new_cost)

        for old_pr, new_pr in zip(plate_refs, new_plate_refs):
            # Find the line entry index to replace for old_pr, considering duplicates
            start_idx = 0
            if old_pr in used_indices:
                # skip already used occurrences
                occurrences = used_indices[old_pr]
            else:
                occurrences = 0

            count_seen = 0
            target_idx = None
            for idx, le in enumerate(ticket.line_entries):
                if le.plate_ref == old_pr:
                    if count_seen == occurrences:
                        target_idx = idx
                        break
                    count_seen += 1

            if target_idx is None:
                raise ValueError(f"Plate {old_pr} not found")

            used_indices[old_pr] = occurrences + 1
            old_entry = ticket.line_entries[target_idx]

            # Validate new plate exists and belongs to the same dish as the old one
            old_dish = self._find_dish_by_plate(old_pr)
            try:
                new_dish = self._find_dish_by_plate(new_pr)
            except ValueError:
                raise ValueError(f"New plate {new_pr} not found")
            if old_dish.dish_ref != new_dish.dish_ref:
                raise ValueError("New plate must be from the same dish as the original")

            new_plate = new_dish.selections[new_pr]
            if not new_plate.served_today:
                raise ValueError(f"New plate {new_pr} is not available today")

            old_cost = old_entry.cost
            new_cost = new_plate.cost
            diff_total += (new_cost - old_cost)

            modifications.append({"index": target_idx, "new_plate": new_plate})

        # Record the payment/refund for the difference
        diff_total = round(diff_total, 2)
        if diff_total != 0:
            ticket.charges.append(
                TicketCharge(
                    kind="payment" if diff_total > 0 else "refund",
                    total=abs(diff_total),
                    instrument_ref=instrument_ref,
                )
            )

        # Apply the modifications
        for mod in modifications:
            idx = mod["index"]
            plate: Plate = mod["new_plate"]
            ticket.line_entries[idx].plate_ref = plate.plate_ref
            ticket.line_entries[idx].cost = plate.cost
            # Keep dish_ref and label as-is; label could be kept consistent with the dish.

        # Mark ticket as placed (items modified). We retain 'placed' state but indicate via label
        # or by relying on ticket history externally. No explicit field exists to flag modifications.
        return ticket

    @is_tool(ToolType.WRITE)
    def modify_placed_ticket_instrument(
        self,
        ticket_ref: str,
        instrument_ref: str,
    ) -> ServiceTicket:
        """Modify the payment instrument on a placed ticket. The agent needs to explain the change
        and ask for explicit user confirmation (yes/no) to proceed.

        Constraints:
        - Only tickets in 'placed' state are eligible.
        - There must be exactly one 'payment' charge on the ticket.
        - The new instrument must be different from the current one.

        Args:
            ticket_ref: The ticket reference, such as 'TCKT-00001'.
            instrument_ref: The new instrument reference to use for the payment.

        Returns:
            ServiceTicket: The ticket details after the modification.

        Raises:
            ValueError: If the ticket is not 'placed'.
            ValueError: If there is not exactly one 'payment' charge.
            ValueError: If the new instrument is the same as the current one.
            ValueError: If the instrument does not exist for the patron.
        """
        ticket = self._get_ticket(ticket_ref)
        if not self._is_placed_ticket(ticket):
            raise ValueError("Non-placed ticket cannot be modified")

        # Validate new instrument exists
        self._get_instrument(ticket.guest_ref, instrument_ref)

        payment_charges = [ch for ch in ticket.charges if ch.kind == "payment"]
        if len(payment_charges) != 1:
            raise ValueError("There should be exactly one payment charge for a placed ticket")

        current_payment = payment_charges[0]
        if current_payment.instrument_ref == instrument_ref:
            raise ValueError("The new instrument should be different from the current one")

        amount = current_payment.total

        # Append a new payment with the new instrument, and a refund to the old instrument
        ticket.charges.extend(
            [
                TicketCharge(kind="payment", total=amount, instrument_ref=instrument_ref),
                TicketCharge(kind="refund", total=amount, instrument_ref=current_payment.instrument_ref),
            ]
        )
        return ticket

    @is_tool(ToolType.WRITE)
    def add_tip_to_ticket(
        self,
        ticket_ref: str,
        tip_total: float,
        instrument_ref: str,
    ) -> ServiceTicket:
        """Add a tip to a ticket. The agent must explain the tip addition and ask for explicit
        user confirmation (yes/no) to proceed.

        Notes:
        - Tip can be added as long as the ticket is not cancelled.
        - The tip is charged to the specified instrument.

        Args:
            ticket_ref: The ticket reference, such as 'TCKT-00001'.
            tip_total: The tip amount to add (must be non-negative).
            instrument_ref: The instrument reference to charge the tip.

        Returns:
            ServiceTicket: The ticket details after adding the tip.

        Raises:
            ValueError: If the ticket is cancelled.
            ValueError: If the tip_total is negative.
            ValueError: If the instrument does not exist for the patron.
        """
        ticket = self._get_ticket(ticket_ref)
        if ticket.state == "cancelled":
            raise ValueError("Cannot add tip to a cancelled ticket")
        if tip_total < 0:
            raise ValueError("Tip amount must be non-negative")

        # Validate instrument
        self._get_instrument(ticket.guest_ref, instrument_ref)

        ticket.charges.append(
            TicketCharge(kind="tip", total=round(float(tip_total), 2), instrument_ref=instrument_ref)
        )
        return ticket


Bank data models in tau2.domains.bank.data_model
```
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, Field

from tau2.environment.db import DB


# -------------------------
# Bank domain enumerations
# -------------------------

AccountType = Literal["checking", "savings", "credit"]
AccountStatus = Literal["active", "frozen", "closed"]

CardType = Literal["debit", "credit"]
CardStatus = Literal["active", "blocked", "expired"]

KYCStatus = Literal["pending", "verified", "failed"]

TransactionType = Literal[
    "deposit", "withdrawal", "transfer", "payment", "fee", "interest"
]
TransactionDirection = Literal["debit", "credit"]
TransactionMethod = Literal["ACH", "Wire", "Card", "ATM", "Internal"]
TransactionStatus = Literal["pending", "posted", "reversed"]

LoanType = Literal["mortgage", "auto", "personal", "credit_line"]
AmortizationType = Literal["fixed", "interest_only", "balloon"]
LoanStatus = Literal["active", "closed", "delinquent", "default"]
CollateralType = Literal["real_estate", "vehicle", "unsecured", "other"]

PaymentScheduleStatus = Literal["due", "paid", "late", "deferred"]

BeneficiaryType = Literal["individual", "business"]
VerificationStatus = Literal["pending", "verified", "failed"]
VerificationMethod = Literal["micro_deposits", "document", "instant"]
BeneficiaryStatus = Literal["active", "suspended", "revoked"]


# -------------------------
# Shared/basic models
# -------------------------

class BankAddress(BaseModel):
    """Represents a physical address in the bank domain"""
    address1: str = Field(description="Primary address line")
    address2: str = Field(description="Secondary address line")
    city: str = Field(description="City name")
    state: str = Field(description="State or province name")
    zip: str = Field(description="Postal code")
    country: str = Field(description="Country name")


class ClientName(BaseModel):
    """Represents a client's full name"""
    first_name: str = Field(description="Client's first name")
    last_name: str = Field(description="Client's last name")
    middle_name: Optional[str] = Field(
        description="Client's middle name", default=None
    )


class ClientContact(BaseModel):
    """Represents a client's contact information"""
    email: str = Field(description="Client's email address")
    phone: str = Field(description="Client's phone number")


# -------------------------
# Account-related models
# -------------------------

class AccountBalance(BaseModel):
    """Represents account balances"""
    current: float = Field(description="Current ledger balance of the account")
    available: float = Field(description="Available balance that can be used")
    on_hold: float = Field(description="Amount currently on hold")


class AccountFeatures(BaseModel):
    """Represents enabled features for an account"""
    checks_enabled: bool = Field(description="Whether checks are enabled for the account")
    atm_access: bool = Field(description="Whether ATM access is enabled")
    online_banking: bool = Field(description="Whether online banking is enabled")


class Account(BaseModel):
    """Represents a bank account"""
    account_id: str = Field(description="Unique identifier for the account")
    type: AccountType = Field(description="Type of the account")
    currency: str = Field(description="Currency code of the account (e.g., USD)")
    status: AccountStatus = Field(description="Current status of the account")
    account_number_masked: str = Field(
        description="Masked account number (e.g., ****1234)"
    )
    routing_number: str = Field(description="Routing number of the account")
    balance: AccountBalance = Field(description="Balances associated with the account")
    interest_rate_apr: Optional[float] = Field(
        description="Annual percentage rate for interest (if applicable)",
        default=None,
    )
    overdraft_limit: Optional[float] = Field(
        description="Overdraft limit for the account (if applicable)",
        default=None,
    )
    opened_at: str = Field(description="Account opening timestamp")
    features: AccountFeatures = Field(description="Enabled features for the account")


# -------------------------
# Card-related models
# -------------------------

class CardExtraInfo(BaseModel):
    """Additional card details"""
    brand: str = Field(description="Card network brand (e.g., Visa, Mastercard)")
    last_four: str = Field(description="Last four digits of the card number")
    exp_month: str = Field(description="Expiration month of the card")
    exp_year: str = Field(description="Expiration year of the card")


class CardLimits(BaseModel):
    """Represents card limits"""
    daily_atm_limit: float = Field(description="Daily ATM withdrawal limit")
    daily_pos_limit: float = Field(description="Daily POS purchase limit")


class Card(BaseModel):
    """Represents a bank card"""
    card_id: str = Field(description="Unique identifier for the card")
    type: CardType = Field(description="Type of the card")
    linked_account_id: str = Field(description="Account ID linked to the card")
    status: CardStatus = Field(description="Current status of the card")
    issuer: str = Field(description="Card issuer name")
    extra_info: CardExtraInfo = Field(description="Additional card information")
    limits: CardLimits = Field(description="Limits applied to the card")
    pin_set: bool = Field(description="Whether a PIN has been set for this card")


# -------------------------
# KYC models
# -------------------------

class KYCInfo(BaseModel):
    """Represents KYC (Know Your Customer) information for a client"""
    status: KYCStatus = Field(description="Current KYC verification status")
    last_reviewed_at: str = Field(description="Timestamp of last KYC review")
    tax_id_masked: str = Field(description="Masked tax ID (e.g., ****1234)")


# -------------------------
# Transaction-related models
# -------------------------

class MerchantInfo(BaseModel):
    """Represents merchant details for card/payment transactions"""
    name: str = Field(description="Merchant name")
    mcc: str = Field(description="Merchant category code")
    city: str = Field(description="Merchant city")
    country: str = Field(description="Merchant country")


class ExchangeInfo(BaseModel):
    """Represents currency exchange details for a transaction"""
    source_currency: str = Field(description="Original currency code")
    target_currency: str = Field(description="Converted currency code")
    rate: float = Field(description="Exchange rate applied")
    source_amount: float = Field(description="Amount in source currency")
    target_amount: float = Field(description="Amount in target currency")


class TransactionFee(BaseModel):
    """Represents a fee applied to a transaction"""
    type: str = Field(description="Type of fee (e.g., wire_fee, overdraft_fee)")
    amount: float = Field(description="Fee amount")
    currency: str = Field(description="Currency code of the fee")


class TransactionHold(BaseModel):
    """Represents an authorization hold on a transaction"""
    is_hold: bool = Field(description="Whether the transaction is currently on hold")
    release_at: Optional[str] = Field(
        description="Timestamp when the hold will be released",
        default=None,
    )
    reason: Optional[str] = Field(
        description="Reason for the hold",
        default=None,
    )


class Transaction(BaseModel):
    """Represents a banking transaction"""
    transaction_id: str = Field(description="Unique identifier for the transaction")
    client_id: str = Field(description="Client ID associated with the transaction")
    account_id: str = Field(description="Account ID associated with the transaction")
    timestamp: str = Field(description="Transaction timestamp")
    type: TransactionType = Field(description="Type/category of the transaction")
    direction: TransactionDirection = Field(
        description="Direction relative to the account (debit or credit)"
    )
    amount: float = Field(description="Transaction amount")
    currency: str = Field(description="Currency code of the transaction amount")
    description: Optional[str] = Field(
        description="Transaction description or memo",
        default=None,
    )
    method: TransactionMethod = Field(description="Processing method of the transaction")
    status: TransactionStatus = Field(description="Current status of the transaction")
    merchant: Optional[MerchantInfo] = Field(
        description="Merchant details for the transaction (if applicable)",
        default=None,
    )
    related_transaction_id: Optional[str] = Field(
        description="Related transaction ID (e.g., transfer counterpart or reversal)",
        default=None,
    )
    exchange: Optional[ExchangeInfo] = Field(
        description="Exchange details if currency conversion occurred",
        default=None,
    )
    fees: List[TransactionFee] = Field(
        description="List of fees applied to the transaction",
        default_factory=list,
    )
    hold: Optional[TransactionHold] = Field(
        description="Hold details if the transaction amount is on hold",
        default=None,
    )
    balance_after: Optional[float] = Field(
        description="Account balance immediately after this transaction",
        default=None,
    )


# -------------------------
# Loan-related models
# -------------------------

class Collateral(BaseModel):
    """Represents collateral for a loan"""
    type: CollateralType = Field(description="Type of collateral")
    description: str = Field(description="Description of the collateral")
    value_amount: float = Field(description="Estimated value of the collateral")
    value_currency: str = Field(description="Currency code for the collateral value")


class LoanPaymentScheduleEntry(BaseModel):
    """Represents a scheduled payment for a loan"""
    due_date: str = Field(description="Due date for the scheduled payment")
    amount: float = Field(description="Amount due for the scheduled payment")
    currency: str = Field(description="Currency code of the scheduled payment")
    status: PaymentScheduleStatus = Field(description="Status of the scheduled payment")
    transaction_id: Optional[str] = Field(
        description="Transaction ID when paid (if applicable)",
        default=None,
    )


class LoanRepaymentHistoryEntry(BaseModel):
    """Represents a repayment history entry for a loan"""
    transaction_id: str = Field(description="Transaction ID of the repayment")
    posted_at: str = Field(description="Timestamp when the repayment was posted")
    amount: float = Field(description="Total repayment amount")
    currency: str = Field(description="Currency code of the repayment")
    method: TransactionMethod = Field(description="Method used for repayment")
    principal_component: float = Field(description="Amount applied to principal")
    interest_component: float = Field(description="Amount applied to interest")
    fees_component: float = Field(description="Amount applied to fees")


class EscrowAccount(BaseModel):
    """Represents an escrow account linked to a loan"""
    account_id: str = Field(description="Account ID of the escrow account")
    balance: float = Field(description="Current escrow balance")
    currency: str = Field(description="Currency code of the escrow account")


class Loan(BaseModel):
    """Represents a loan"""
    loan_id: str = Field(description="Unique identifier for the loan")
    client_id: str = Field(description="Client ID that owns the loan")
    linked_repayment_account_id: str = Field(
        description="Account ID used for repayments"
    )
    type: LoanType = Field(description="Type of loan")
    principal: float = Field(description="Original principal amount of the loan")
    currency: str = Field(description="Currency code of the loan")
    interest_rate_apr: float = Field(description="Annual percentage rate for the loan")
    amortization: AmortizationType = Field(description="Amortization type of the loan")
    term_months: int = Field(description="Loan term in months")
    origination_date: str = Field(description="Origination date of the loan")
    first_payment_date: str = Field(description="Date of the first payment")
    maturity_date: str = Field(description="Loan maturity date")
    status: LoanStatus = Field(description="Current status of the loan")
    collateral: Optional[Collateral] = Field(
        description="Collateral details for the loan (if applicable)",
        default=None,
    )
    payment_schedule: List[LoanPaymentScheduleEntry] = Field(
        description="Scheduled payments for the loan"
    )
    repayment_history: List[LoanRepaymentHistoryEntry] = Field(
        description="Repayment history entries for the loan"
    )
    escrow: Optional[EscrowAccount] = Field(
        description="Escrow account details (if applicable)",
        default=None,
    )


# -------------------------
# Beneficiary-related models
# -------------------------

class BeneficiaryName(BaseModel):
    """Represents a beneficiary's name information"""
    display_name: Optional[str] = Field(
        description="Display name for the beneficiary", default=None
    )
    first_name: Optional[str] = Field(
        description="First name of the beneficiary", default=None
    )
    last_name: Optional[str] = Field(
        description="Last name of the beneficiary", default=None
    )
    business_name: Optional[str] = Field(
        description="Business name, if beneficiary is a business", default=None
    )


class BankDetails(BaseModel):
    """Represents bank details for a beneficiary"""
    bank_name: str = Field(description="Name of the beneficiary's bank")
    account_number_masked: str = Field(
        description="Masked account number for the beneficiary"
    )
    routing_number: Optional[str] = Field(
        description="Routing number for domestic transfers (if applicable)",
        default=None,
    )
    iban: Optional[str] = Field(
        description="IBAN for international transfers (if applicable)",
        default=None,
    )
    swift_bic: Optional[str] = Field(
        description="SWIFT/BIC code for international transfers (if applicable)",
        default=None,
    )


class TransferLimits(BaseModel):
    """Represents transfer limits for a beneficiary"""
    per_transfer_limit: float = Field(description="Maximum amount per transfer")
    daily_limit: float = Field(description="Maximum total daily transfer limit")


class BeneficiaryVerification(BaseModel):
    """Represents beneficiary verification details"""
    status: VerificationStatus = Field(description="Verification status")
    method: VerificationMethod = Field(description="Verification method used")
    verified_at: Optional[str] = Field(
        description="Timestamp when verification was completed",
        default=None,
    )


class Beneficiary(BaseModel):
    """Represents a beneficiary authorized by a client"""
    beneficiary_id: str = Field(description="Unique identifier for the beneficiary")
    client_id: str = Field(
        description="Client ID who owns/authorized this beneficiary"
    )
    name: BeneficiaryName = Field(description="Name information of the beneficiary")
    type: BeneficiaryType = Field(description="Type of beneficiary")
    bank_details: BankDetails = Field(description="Bank details of the beneficiary")
    address: BankAddress = Field(description="Address of the beneficiary")
    allowed_from_account_ids: List[str] = Field(
        description="List of account IDs from which transfers to this beneficiary are allowed"
    )
    transfer_limits: TransferLimits = Field(
        description="Transfer limits for this beneficiary"
    )
    verification: BeneficiaryVerification = Field(
        description="Verification details for this beneficiary"
    )
    status: BeneficiaryStatus = Field(description="Current status of the beneficiary")
    created_at: str = Field(description="Timestamp when the beneficiary was created")
    notes: Optional[str] = Field(
        description="Additional notes related to the beneficiary",
        default=None,
    )


# -------------------------
# Client model
# -------------------------

class Client(BaseModel):
    """Represents a bank client with their accounts, cards, and related entities"""
    client_id: str = Field(description="Unique identifier for the client")
    name: ClientName = Field(description="Client's full name")
    contact: ClientContact = Field(description="Client's contact information")
    address: BankAddress = Field(description="Client's primary address")
    accounts: Dict[str, Account] = Field(
        description="Dictionary of accounts indexed by account ID"
    )
    cards: Dict[str, Card] = Field(
        description="Dictionary of cards indexed by card ID"
    )
    loan_ids: List[str] = Field(
        description="List of loan IDs associated with this client"
    )
    beneficiary_ids: List[str] = Field(
        description="List of beneficiary IDs authorized by this client"
    )
    created_at: str = Field(description="Timestamp when the client profile was created")
    kyc: KYCInfo = Field(description="KYC information for the client")


# -------------------------
# Bank database
# -------------------------

class BankDB(DB):
    """Database containing all bank-related data including clients, transactions, loans and beneficiaries"""

    clients: Dict[str, Client] = Field(
        description="Dictionary of all clients indexed by client ID"
    )
    transactions: Dict[str, Transaction] = Field(
        description="Dictionary of all transactions indexed by transaction ID"
    )
    loans: Dict[str, Loan] = Field(
        description="Dictionary of all loans indexed by loan ID"
    )
    beneficiaries: Dict[str, Beneficiary] = Field(
        description="Dictionary of all beneficiaries indexed by beneficiary ID"
    )

    def get_statistics(self) -> dict[str, Any]:
        """Get the statistics of the bank database."""
        num_clients = len(self.clients)
        num_transactions = len(self.transactions)
        num_loans = len(self.loans)
        num_beneficiaries = len(self.beneficiaries)
        total_accounts = sum(len(client.accounts) for client in self.clients.values())
        total_cards = sum(len(client.cards) for client in self.clients.values())
        total_current_balance = sum(
            sum(account.balance.current for account in client.accounts.values())
            for client in self.clients.values()
        )
        return {
            "num_clients": num_clients,
            "num_transactions": num_transactions,
            "num_loans": num_loans,
            "num_beneficiaries": num_beneficiaries,
            "total_accounts": total_accounts,
            "total_cards": total_cards,
            "total_current_balance": total_current_balance,
        }
```

Following the formats of restaurant tools, write new and frequently-used tools based on bank data models. Please reuse base models in restaurant tools.
Wrap the python code within ```.
