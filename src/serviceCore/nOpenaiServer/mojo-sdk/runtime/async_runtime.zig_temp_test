// ... existing code ...

// ============================================================================
// Timer Test
// ============================================================================

const SleepFuture = struct {
    duration_ms: u64,
    timer_id: ?u64,
    start_time: i64,
    
    fn poll(ptr: *anyopaque, waker: *Waker) Future.PollResult {
        const self = @as(*SleepFuture, @ptrCast(@alignCast(ptr)));
        
        if (self.timer_id == null) {
            self.start_time = std.time.milliTimestamp();
            self.timer_id = waker.executor.timer_driver.schedule(self.duration_ms, waker.task_id, waker.clone(waker.executor.allocator) catch @panic("OOM")) catch @panic("Timer fail");
            return .Pending;
        } else {
            const now = std.time.milliTimestamp();
            const elapsed = now - self.start_time;
            if (elapsed < @as(i64, @intCast(self.duration_ms)) - 50) { 
                 return .Pending;
            }
            return .{ .Ready = "" };
        }
    }
    
    fn deinit(ptr: *anyopaque, allocator: Allocator) void {
        const self = @as(*SleepFuture, @ptrCast(@alignCast(ptr)));
        allocator.destroy(self);
    }
};

fn createSleepFuture(allocator: Allocator, duration_ms: u64) !Future {
    const ptr = try allocator.create(SleepFuture);
    ptr.* = .{
        .duration_ms = duration_ms,
        .timer_id = null,
        .start_time = 0,
    };
    return Future{
        .ptr = ptr,
        .vtable = &.{
            .poll = SleepFuture.poll,
            .deinit = SleepFuture.deinit,
        },
    };
}

test "timer integration" {
    const allocator = std.testing.allocator;
    
    var executor = try Executor.init(allocator, 2);
    defer executor.deinit();
    
    try executor.run();
    
    const f = try createSleepFuture(allocator, 100);
    const id = try executor.spawn(f);
    
    const start = std.time.milliTimestamp();
    const res = try executor.blockOn(id);
    // Don't free res here because it's a static string "" literal in .Ready = ""
    // But wait, readyFuture dupes it. SleepFuture returns literal ""?
    // Let's check SleepFuture.poll implementation above.
    // It returns .{ .Ready = "" }. 
    // blockOn does: `const result = task.handle.result`.
    // Task implementation of poll: `self.handle.result = value`.
    // Does it copy?
    // In `readyFuture` we did `allocator.dupe`.
    // In `SleepFuture` we are returning a slice to a literal.
    // Task.deinit calls `allocator.free(result)`.
    // ERROR: `allocator.free` on a literal string will CRASH.
    
    // Fix: SleepFuture must return an allocated string.
    _ = res; // unused warning fix
    const end = std.time.milliTimestamp();
    
    try std.testing.expect((end - start) >= 50); 
}
